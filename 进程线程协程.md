# 进程线程协程

[如何理解：程序、进程、线程、并发、并行、高并发？](https://www.zhihu.com/question/307100151/answer/894486042)

## 进程，和另一种进程

进程的英文Process本意就是“过程”的意思，是一个抽象的概念。这个活有没有真得干并不重要，重要的是你已经预先想好了这个活该怎么干，**有了一个可行思路**。注意，这里【进程】仅仅是描述这个方案的。至于这个方案是在脑海里，还是已经被执行了，是不重要的

大家更加熟知的进程往往指的是另外一个意思，是指“程序在[操作系统](https://www.zhihu.com/search?q=操作系统&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A894486042})中运行的实例“。所谓“实例”是指同一个程序可以同时在操作系统里实际的运行。就像是如果你的[铺路程序](https://www.zhihu.com/search?q=铺路程序&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A894486042})写好了，可以铺好几条路。每一个具体的铺路工作是一个“实例”

In computing, a **process** is the [instance](https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Instance_(computer_science)) of a [computer program](https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Computer_program) that is being executed by one or many threads.

## 线程

但在Linux中，【线程】是被实现为“轻量级进程”的。也就是说在Linux中的进程和线程实现的本质是一样的。只不过在以下2点上有显著区别：

- 在资源消耗上进程的消耗多，线程消耗相对少，以及；
- 内存空间上有一些不同：进程的[虚拟内存](https://www.zhihu.com/search?q=虚拟内存&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A894486042})彼此隔离，而线程则共享同一虚拟内存空间有些不同。

但Linux中【OS进程】和【线程】都用作任务调度单位。因此，**Linux这种实现方式和理论上的概念不是很吻合**

## 并发

假设自己一个人按照一定的步骤来铺路，一个人从头干到尾，这是一个“[串行](https://www.zhihu.com/search?q=串行&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A894486042})”的【P进程】

【并发】的【P进程】。换成说人话就是，**你有一套方案，可以让多个人一起把事情做的更高效**。注意是“**可以**“让事情更高效，而不是“必然“让事情更高效

当你想把一个【并发】的【P进程】写成程序时，你怎么用编程语言告诉操作系统你的程序的一些步骤是【并发】的。更确切地说，你需要一个写法（可能是语法，也可能是函数库）表达：

- 几个任务是【并发】的
- 【并发】的任务之间是怎么交互协作的

为了解决这两个问题，人们总结了一些方法，并将其称为“并发模型”。

比如：

- Fork & Join模型（大任务拆解为小任务并发的跑，结果再拼起来）
- Actor模型（干活的步骤之间直接发消息）
- CSP模型（干活的步骤之间订阅通话的频道来协作）
- 线程&锁模型

## 并行

在软件系统中，【程序】是否能【并行】运行，要看物理上有多少个CPU核心可以同时干活（或者再扩展一下，有多少台可用的物理主机）。

比如你写了个Java程序，同时启动了4个线程，但CPU只有单核，那么同一时刻只有一个线程在运行。如果有4个CPU核心，那么可以做到4个线程完全【并行】运行。如果有2个核心，那么就处于一种中间态。比如你可以用“并发度=4“，”[并行度](https://www.zhihu.com/search?q=并行度&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A894486042})=2“形容这种情况

## 为啥要并发

把事情设计为【并发】有什么好处呢？假如能同时干活的人只有1个，其实并没有什么好处。【并发】的方法的总耗时总会>=串行的方法。因为【并发】或多或少总会引入需要协作和沟通成本。最小的代价就是不需要沟通，此时【并发】的方法和串行的方法工作量是一样的。

但是【并发】的巨大优势是在可以干活的人数量变多时，马上得到【并行】的好处。假如我们可以得到一个【并发】的【P进程】，并且真的为其配备足够多的人，那么做事的效率就会高很多

## 并发和并行的关系是什么

- **Concurrency is not Parallelism**
- **Concurrency enables parallelism & makes parallelism (and scaling and everything else) easy**

前一个观点【并发】和【并行】不是一件事，我们都可以理解了。【并发】说的是**处理**（Deal）的方法；【并行】说的是**执行**（Execution）的方法。

后一个观点指的是，如果想让一个事情变得容易【并行】，先得让制定一个【并发】的方法。倘若一个事情压根就没有【并发】的方法，那么无论有多少个可以干活的人，也不能【并行】

## 常见的误解

你可能看到过下面的论断：

> **并发**是多个任务交替使用CPU，同一时刻只有一个任务在跑；**并行**是多个任务同时跑

这个理解不能说全错，但是合到一起就形成了错误的理解。这个错误的理解就是：并发和并行是两个并列的，非此即彼的概念，一个状态要不就是并行的，要不就是并发的。这是完全错误的，实际上看到上面的解释你就会发现【并发】和【并行】描述的是两个频道的事情。正如Rob Pike所言，一个是“如何处理”，一个是“如何执行”。因此，对于：

> **并发**是多个任务交替使用CPU，同一时刻只有一个任务在跑

其实正确的理解是：针对一个问题，想到了一个可以拆解为多个【并发】的任务，这些任务执行时因为只有一个CPU只能“切换”的跑。

对于：

> **并行**是多个任务同时跑

其实的意思是：如果这些并行执行的任务是解决同一个问题的，那么他们既是【并发】的，同时也是【并行】的。

那么可不可以做到只【并行】，而不【并发】呢？当然可以，但这也就意味着【并行】的程序之间没有什么关联，各干各的，就像大街上来来往往的陌生人一样。这的确是【并行】，并且是这个世界的常态。但是一群不认识的，各干各的人是不能一起解决问题的，要一起就得有同一个目标，制定一套沟通的方法，形成【并发】的方案。这种形式在现实当中就是“公司

## 为什么要这么理解并发

将并发理解为一种解决问题的方法，其主要用意是表达：一个问题的解决方案是可以由许许多多的并发任务组装（compose）到一起的。这有点像OOP里表达一个类可以由其他类的成员组装到一起一样。

**将大的任务拆解为许许多多小的可以并发的任务是重要的编程思想**

## 高并发

【高并发】是指可以让软件系统在一段时间内能够处理大量的请求。比如每秒钟可以完成10万个请求。这是互联网系统的一个重要的特征。

不像【并发】说的是“处理”，【并行】说的是“执行”，【高并发】说的是**最终效果**。只要能达到效果，不管怎么实现都行。因此，极端一点【高并发】甚至并不一定需要【并行】，只要处理速度快的足够满足要求就可以。如启动一个nginx的【OS进程】，它只能用到一个CPU核心，也就不可能【并行】。但是他如果能每秒能处理10万个请求，而业务需求只要求8万个请求就可以了，那么这个单进程的nginx本身就算【高并发】了