# 二进制

## 原码, 反码和补码

[我C，原码/反码/补码，我特喵也忘个精光...](https://mp.weixin.qq.com/s/laP7Vxl6o40mIYBS7Cuj7A)

原理分析很好

### 机器数和真值

+ 机器数
  一个数在计算机中的二进制表示形式,  叫做这个数的机器数。机器数是带符号的，在计算机用一个数的最高位存放符号, 正数为0, 负数为1

+ 真值
  因为第一位是符号位，所以机器数的形式值就不等于真正的数值。为区别起见，将带符号位的机器数对应的真正数值称为机器数的真值

原码, 反码, 补码的基础概念和计算方法

+ 原码
  原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值

  取值范围[-127 , 127]

+ 反码

  正数的反码是其本身

  负数的反码是在其原码的基础上, 符号位不变，其余各个位取反

  取值范围[-127, +127]

+ 补码

  正数的补码就是其本身

  负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)

  取值范围[-128, +127]

```
[+1] = [00000001]原 = [00000001]反 = [00000001]补

[-1] = [10000001]原 = [11111110]反 = [11111111]补
```

### 为何要使用原码, 反码和补码

可见原码, 反码和补码是完全不同的. 既然原码才是被人脑直接识别并用于计算表示方式, 为何还会有反码和补码呢?

首先, 因为人脑可以知道第一位是符号位, 在计算的时候我们会根据符号位, 选择对真值区域的加减. (真值的概念在本文最开头). 但是对于计算机, 加减乘数已经是最基础的运算, 要设计的尽量简单. 计算机辨别"符号位"显然会让计算机的基础电路设计变得十分复杂! 于是人们想出了将符号位也参与运算的方法. 我们知道, 根据运算法则减去一个正数等于加上一个负数, 即: 1-1 = 1 + (-1) = 0 , 所以机器可以只有加法而没有减法, 这样计算机运算的设计就更简单了.

于是人们开始探索 将符号位参与运算, 并且只保留加法的方法

+ 如果用原码表示, 让符号位也参与计算, 显然对于减法来说, 结果是不正确的.这也就是为何计算机内部不使用原码表示一个数

+ 为了解决原码做减法的问题, 出现了反码

  发现用反码计算减法, 结果的真值部分是正确的. 而唯一的问题其实就出现在"0"这个特殊的数值上. 虽然人们理解上+0和-0是一样的, 但是0带符号是没有任何意义的. 而且会有[0000 0000]原和[1000 0000]原两个编码表示0

+ 于是补码的出现, 解决了0的符号以及两个编码的问题

  在用补码运算的结果中, [1000 0000]补 就是-128. 但是注意因为实际上是使用以前的-0的补码来表示-128, 所以-128并没有原码和反码表示.(对-128的补码表示[1000 0000]补算出来的原码是[0000 0000]原, 这是不正确的)

## 移位运算

左移时，无论是图形还是数值，移位后，只需要将低位补 0 即可；右移时，需要根据情况判断是逻辑右移还是算数右移

+ 逻辑右移：最高位填充0
+ 将二进制数作为带符号的数值进行右移运算时，移位后需要在最高位填充移位前符号位的值( 0 或 1)。这就被称为算数右移